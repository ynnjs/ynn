'use strict';
/******************************************************************
 * Copyright (C) 2021 LvChengbin
 *
 * File: metadata/index.ts
 * Author: LvChengbin<lvchengbin59@gmail.com>
 * Time: 01/30/2021
 * Description:
 ******************************************************************/
var __createBinding = this && this.__createBinding || ( Object.create ? function( o, m, k, k2 ) {
    if( k2 === undefined ) k2 = k;
    Object.defineProperty( o, k2, { enumerable : true, get : function() { return m[ k ] } } );
} : function( o, m, k, k2 ) {
    if( k2 === undefined ) k2 = k;
    o[ k2 ] = m[ k ];
} );
var __exportStar = this && this.__exportStar || function( m, exports ) {
    for( var p in m ) if( p !== 'default' && !Object.prototype.hasOwnProperty.call( exports, p ) ) __createBinding( exports, m, p );
};
Object.defineProperty( exports, '__esModule', { value : true } );
exports.getMetadataParameter = exports.saveMetadataParameter = exports.getMetadataFinally = exports.saveMetadataFinally = exports.getMetadataException = exports.saveMetadataException = exports.getMetadataAfter = exports.saveMetadataAfter = exports.getMetadataBefore = exports.saveMetadataBefore = void 0;
const constants_1 = require( '../constants' );
const storage_1 = require( '../storage' );
__exportStar( require( './metadata.interface' ), exports );
/**
 * Store the method into storage and return the generated key
 *
 * @param method - the method need to be stored
 *
 * @return the key generated by `Storage.key()`
 */
function storeMethod( method ) {
    const key = storage_1.Storage.key();
    storage_1.Storage.set( key, method );
    return key;
}
function saveMethodMetadata( key, descriptorOrConstructor, metadata ) {
    const target = typeof descriptorOrConstructor === 'function' ? descriptorOrConstructor : descriptorOrConstructor.value;
    const metadatas = Reflect.getMetadata( key, target ) || [];
    metadatas.push( metadata );
    Reflect.defineMetadata( key, metadatas, target );
}
function getMethodMetadata( descriptorOrConstructor ) {
    return Reflect.getMetadata( constants_1.KEY_BEFORE, typeof descriptorOrConstructor === 'function' ? descriptorOrConstructor : descriptorOrConstructor.value );
}
/**
 * save metadata for interceptor before.
 *
 * @param descriptor
 * @param method
 * @param options
 */
function saveMetadataBefore( descriptor, method, options = {} ) {
    const metadata = {
        type : storeMethod( method ),
        interceptorType : 'before'
    };
    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }
    saveMethodMetadata( constants_1.KEY_BEFORE, descriptor, metadata );
}
exports.saveMetadataBefore = saveMetadataBefore;
function getMetadataBefore( descriptorOrConstructor ) {
    return getMethodMetadata( descriptorOrConstructor );
}
exports.getMetadataBefore = getMetadataBefore;
/**
 * save metadata for interceptor after
 *
 * @param descriptor
 * @param method
 * @param options
 */
function saveMetadataAfter( descriptor, method, options = {} ) {
    const metadata = {
        type : storeMethod( method ),
        interceptorType : 'after'
    };
    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }
    saveMethodMetadata( constants_1.KEY_AFTER, descriptor, metadata );
}
exports.saveMetadataAfter = saveMetadataAfter;
function getMetadataAfter( descriptorOrConstructor ) {
    return getMethodMetadata( descriptorOrConstructor );
}
exports.getMetadataAfter = getMetadataAfter;
/**
 * save metadata for interceptor exception
 *
 * @param descriptor
 * @param method
 * @param options
 */
function saveMetadataException( descriptorOrConstructor, method, options = {} ) {
    const metadata = {
        type : storeMethod( method ),
        interceptorType : 'exception'
    };
    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }
    if( 'exceptionType' in options ) {
        metadata.exceptionType = options.exceptionType;
    }
    saveMethodMetadata( constants_1.KEY_EXCEPTION, descriptorOrConstructor, metadata );
}
exports.saveMetadataException = saveMetadataException;
function getMetadataException( descriptorOrConstructor ) {
    return getMethodMetadata( descriptorOrConstructor );
}
exports.getMetadataException = getMetadataException;
/**
 * save metadata for interceptor finally
 *
 * @param descriptorOrConstructor
 */
function saveMetadataFinally( descriptorOrConstructor, method, options = {} ) {
    const metadata = {
        type : storeMethod( method ),
        interceptorType : 'finally'
    };
    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }
    saveMethodMetadata( constants_1.KEY_FINALLY, descriptorOrConstructor, metadata );
}
exports.saveMetadataFinally = saveMetadataFinally;
function getMetadataFinally( descriptorOrConstructor ) {
    return getMethodMetadata( descriptorOrConstructor );
}
exports.getMetadataFinally = getMetadataFinally;
/**
 * save metadata for interceptor parameter
 *
 * @param target
 * @param key
 * @param i
 * @param method
 * @param options
 */
function saveMetadataParameter(target, // eslint-disable-line
    key, i, method, options = {} ) {
    const metadata = {
        type : storeMethod( method ),
        interceptorType : 'parameter'
    };
    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }
    const metadatas = Reflect.getMetadata( constants_1.KEY_PARAMETER, target, key ) || [];
    if( !metadatas[ i ] )
        metadatas[ i ] = [ metadata ];
    else
        metadatas[ i ].push( metadata );
    Reflect.defineMetadata( constants_1.KEY_PARAMETER, metadatas, target, key );
}
exports.saveMetadataParameter = saveMetadataParameter;
function getMetadataParameter( ...args ) {
    return Reflect.getMetadata( constants_1.KEY_PARAMETER, ...args );
}
exports.getMetadataParameter = getMetadataParameter;
