/******************************************************************
 * Copyright (C) 2021 LvChengbin
 *
 * File: metadata/index.ts
 * Author: LvChengbin<lvchengbin59@gmail.com>
 * Time: 01/30/2021
 * Description:
 ******************************************************************/

import { VariadicFunction, GlobalFunction, VariadicObject } from '@ynn/utility-types';
import { KEY_BEFORE, KEY_AFTER, KEY_EXCEPTION, KEY_PARAMETER, KEY_FINALLY } from '../constants';
import { Storage } from '../storage';
import { Metadata, MetadataBefore, MetadataAfter, MetadataException, MetadataParameter, MetadataFinally } from './metadata.interface';
import { MethodBefore, MethodAfter, MethodException, MethodParameter, MethodFinally } from '../method.interface';
export * from './metadata.interface';


/**
 * Store the method into storage and return the generated key
 *
 * @param method - the method need to be stored
 *
 * @return the key generated by `Storage.key()`
 */
function storeMethod( method: VariadicFunction ): symbol {
    const key = Storage.key();
    Storage.set( key, method );
    return key;
}

function saveMethodMetadata<T>(
    key: symbol | string,
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction,
    metadata: T
): void {
    const target = typeof descriptorOrConstructor === 'function' ? descriptorOrConstructor : descriptorOrConstructor.value;
    const metadatas: T[] = Reflect.getMetadata( key, target ) || [];
    metadatas.push( metadata );
    Reflect.defineMetadata( key, metadatas, target );
}

function getMethodMetadata<T = Metadata>(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction
): ( T | undefined )[] {
    return Reflect.getMetadata( KEY_BEFORE, typeof descriptorOrConstructor === 'function' ? descriptorOrConstructor : descriptorOrConstructor.value );
}

/**
 * save metadata for interceptor before.
 *
 * @param descriptor
 * @param method
 * @param options
 */
export function saveMetadataBefore<T extends unknown[]>(
    descriptor: PropertyDescriptor | GlobalFunction,
    method: MethodBefore<T>,
    options: Readonly<Pick<MetadataBefore, 'parameters'>> = {}
): void {

    const metadata: MetadataBefore = {
        type : storeMethod( method ),
        interceptorType : 'before'
    };

    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }

    saveMethodMetadata( KEY_BEFORE, descriptor, metadata );
}

export function getMetadataBefore(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction
): ( MetadataBefore | undefined )[] {
    return getMethodMetadata<MetadataBefore>( descriptorOrConstructor );
}

/**
 * save metadata for interceptor after
 *
 * @param descriptor
 * @param method
 * @param options
 */
export function saveMetadataAfter<T extends unknown[]>(
    descriptor: PropertyDescriptor | GlobalFunction,
    method: MethodAfter<T>,
    options: Pick<MetadataAfter, 'parameters'> = {}
): void {
    const metadata: MetadataAfter = {
        type : storeMethod( method ),
        interceptorType : 'after'
    };

    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }
    saveMethodMetadata( KEY_AFTER, descriptor, metadata );
}

export function getMetadataAfter(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction
): ( MetadataAfter | undefined )[] {
    return getMethodMetadata<MetadataAfter>( descriptorOrConstructor );
}

/**
 * save metadata for interceptor exception
 *
 * @param descriptor
 * @param method
 * @param options
 */
export function saveMetadataException<T extends unknown[]>(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction,
    method: MethodException<T>,
    options: Pick<MetadataException, 'exceptionType' | 'parameters'> = {}
): void {

    const metadata: MetadataException = {
        type : storeMethod( method ),
        interceptorType : 'exception'
    };

    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }

    if( 'exceptionType' in options ) {
        metadata.exceptionType = options.exceptionType;
    }
    saveMethodMetadata( KEY_EXCEPTION, descriptorOrConstructor, metadata );
}

export function getMetadataException(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction
): ( MetadataException | undefined )[] {
    return getMethodMetadata<MetadataException>( descriptorOrConstructor );
}

/**
 * save metadata for interceptor finally
 *
 * @param descriptorOrConstructor
 */
export function saveMetadataFinally<T extends unknown[]>(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction,
    method: MethodFinally<T>,
    options: Pick<MetadataFinally, 'parameters'> = {}
): void {

    const metadata: MetadataFinally = {
        type : storeMethod( method ),
        interceptorType : 'finally'
    };

    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }

    saveMethodMetadata( KEY_FINALLY, descriptorOrConstructor, metadata );
}

export function getMetadataFinally(
    descriptorOrConstructor: PropertyDescriptor | GlobalFunction
): ( MetadataFinally | undefined )[] {
    return getMethodMetadata<MetadataFinally>( descriptorOrConstructor );
}


/**
 * save metadata for interceptor parameter
 *
 * @param target
 * @param key
 * @param i
 * @param method
 * @param options
 */
export function saveMetadataParameter<T extends unknown[]>(
    target: object, // eslint-disable-line
    key: string | symbol,
    i: number,
    method: MethodParameter<T>,
    options: Readonly<Pick<MetadataParameter, 'parameters'>> = {}
): void {
    const metadata: MetadataParameter = {
        type : storeMethod( method ),
        interceptorType : 'parameter'
    };

    if( 'parameters' in options ) {
        metadata.parameters = options.parameters;
    }

    const metadatas: MetadataParameter[][] = Reflect.getMetadata( KEY_PARAMETER, target, key ) || [];

    if( !metadatas[ i ] ) metadatas[ i ] = [ metadata ];
    else metadatas[ i ].push( metadata );

    Reflect.defineMetadata( KEY_PARAMETER, metadatas, target, key );
}

export function getMetadataParameter( ...args: [
    target: VariadicObject,
    key?: string | symbol
] ): ( MetadataParameter | undefined )[] {
    return Reflect.getMetadata( KEY_PARAMETER, ...args as [ VariadicObject ] );
}
