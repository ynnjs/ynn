/******************************************************************
 * Copyright (C) 2020 LvChengbin
 *
 * File: interceptor/extract.ts
 * Author: LvChengbin<lvchengbin59@gmail.com>
 * Time: 12/24/2020
 * Description:
 ******************************************************************/

import { VariadicClass, ParametersShift } from '@ynn/utility-types';
import { KEY_BEFORE, KEY_AFTER, KEY_EXCEPTION, KEY_PARAMETER } from '../constants';
import { Metadata, MetadataBefore, MetadataAfter, MetadataParameter, MetadataException } from '../metadata.interface';
import { MethodBefore, MethodAfter, MethodException, MethodParameter, Methods, MethodInfo } from './interceptor.interface';

/**
 * extract all interceptor methods of a descriptor with specific key from a method pool.
 *
 * @typeparam T - the type of meadata, it should be extended from Metadata interface
 * @typeparam M - the type of values for methods object.
 *
 * @param key - the key for metadata
 * @param descriptor - the target descriptor of the class instance method.
 * @param methods - the method pool that provides interceptor methods.
 *
 * @returns a list of information of extracted methods
 */
function extractMethods<T extends Metadata, M>( key: keyof Methods, descriptor: PropertyDescriptor, methods: Methods<M> ) {

    const bound: MethodInfo<T, M>[] = [];

    Reflect.getMetadata( key, descriptor.value )?.forEach( ( metadata: T ) => {
        /**
         * do nothing even if methods[ metadata.type ] is not a function or is undefined.
         */
        bound.push( { method : methods[ metadata.type ], metadata } );
    } );

    return bound;
}

/**
 * extract the before interceptor
 *
 * @param descriptor - the target descriptor of the class instance method.
 * @param methods - the method pool that provides interceptor methods.
 *
 * @return a list of information of extracted methods for *BEFORE INTERCEPTOR*.
 */
function before( ...args: ParametersShift<typeof extractMethods> ): MethodInfo<MetadataBefore>[] {
    return extractMethods<MetadataBefore, MethodBefore>( KEY_BEFORE, ...args );
}


function after( ...args: ParametersShift<typeof extractMethods> ): MethodInfo<MetadataAfter>[] {
    return extractMethods<MetadataAfter, MethodAfter>( KEY_AFTER, ...args );
}

function exception( ...args: ParametersShift<typeof extractMethods> ): MethodInfo<MetadataException>[] {
    return extractMethods<MetadataException, MethodException>( KEY_EXCEPTION, ...args );
}

function parameter( constructor: VariadicClass, methodName: keyof Methods, methods: Methods<MethodParameter> ): MethodInfo<Partial<MetadataParameter, MethodParameter>>[] {

    const bound: MethodInfo<Partial<MetadataParameter>, MethodParameter>[] = [];

    /**
     * get metadata for PARAMETER INTERCEPTOR of given method.
     */
    const metadatas: MetadataParameter[] = Reflect.getMetadata( KEY_PARAMETER, constructor.prototype, methodName ) || [];

    /**
     * get the parameters metadata which is generated by typescript automatically
     */
    Reflect.getMetadata( 'design:paramtypes', constructor.prototype, methodName ).forEach( ( paramtype: unknown, i: number ) => {

        /**
         * combine paramtypes and metadatas for interceptor.
         */
        const metadata = metadatas[ i ] || {};

        bound.push( {
            method : methods[ metadata.type ],
            metadata : {
                ...metadata,
                paramtype
            }
        } );
    } );

    return bound;
}

export default { before, after, exception, parameter };
